# -*- coding: utf-8 -*-
"""stock_price_preidctor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jSMNIvvuLdb1L1i89eGOVCTxH9DZ6GqY

Closing price of a stock is predicted

**Moving average(MA)** is a commonly used statistical indicator to analyze data trends over a specific period of time. It helps to smooth out fluctuations or noise in the data and provides a clearer picture of the underlying trend.
It is calculated by taking the average of a specified number of data points within a sliding window that moves through the dataset. As new data points become available, the window shifts, and the average is recalculated.

Strategy of Technical analyst to analyze stock
If the 100-day MA crosses above the 200-day MA, it suggests that the shorter-term average is rising faster than the longer-term average, indicating
**uptrend** and vice-versa

Offset is difference between original and predicted price

Data is scrapped from yahoo finance
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import pandas_datareader as data

# start = '2013-06-10'
# end = '2023-06-10'
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf
start = '2013-06-10'
end = '2023-06-10'
ticker = "AAPL"
df = yf.download(ticker,start, end)
df.head()

df = df.reset_index()
df.head()

df=df.drop(['Date','Adj Close'],axis=1)
df.head()

plt.plot(df.Close)

ma100 = df.Close.rolling(100).mean()
ma100

plt.figure(figsize=(12,6))
plt.plot(df.Close)
plt.plot(ma100,'r')

ma200 = df.Close.rolling(200).mean()
ma200

plt.figure(figsize=(12,6))
plt.plot(df.Close)
plt.plot(ma100,'r')
plt.plot(ma200,'g')

df.shape

"""Splitting data into training and testing"""

data_training = pd.DataFrame(df['Close'][0:int(len(df)*0.70)])
data_testing  =  pd.DataFrame(df['Close'][int(len(df)*0.70):int(len(df))])
print(data_training.shape)
print(data_testing.shape)

data_training.head()

data_testing.head()

"""**MIN_MAX NORMALIZATION**"""

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(0,1))

data_training_array = scaler.fit_transform(data_training)
data_training_array

data_training_array.shape

x_train = []
y_train = []
for i in range(100,data_training_array.shape[0]):
  x_train.append(data_training_array[i-100:i])
  y_train.append(data_training_array[i,0])

x_train , y_train = np.array(x_train),np.array(y_train)
print(x_train.shape)

"""**LSTM ML MODEL**

LSTM (Long Short-Term Memory): LSTM is a type of recurrent neural network (RNN) architecture that is well-suited for processing and making predictions on sequences of data. LSTM networks have the ability to learn long-term dependencies in the data by using a memory cell and different types of gates to control the flow of information.

"""

from keras.layers import Dense,Dropout,LSTM
from keras.models import Sequential

model = Sequential()
model.add(LSTM(units = 50, activation = 'relu',return_sequences= True,input_shape = (x_train.shape[1],1)))
model.add(Dropout(0.2))

model.add(LSTM(units = 60, activation = 'relu',return_sequences= True))
model.add(Dropout(0.3))

model.add(LSTM(units = 80, activation = 'relu',return_sequences= True))
model.add(Dropout(0.4))

model.add(LSTM(units = 120, activation = 'relu'))
model.add(Dropout(0.5))

model.add(Dense(units = 1))

model.summary()

model.compile(optimizer='adam',loss='mean_squared_error')
model.fit(x_train,y_train,epochs=50)

model.save('stock_price_model.h5')

data_testing.head()

past_100_days = data_training.tail(100)
final_df = past_100_days.append(data_testing,ignore_index=True)
final_df

input_data = scaler.fit_transform(final_df)
input_data

input_data.shape

x_test = []
y_test = []
for i in range(100,input_data.shape[0]):
  x_test.append(input_data[i-100:i])
  y_test.append(input_data[i,0])

x_test,y_test = np.array(x_test),np.array(y_test)
print(x_test.shape)
print(y_test.shape)

y_predicted = model.predict(x_test)
y_predicted.shape

y_test

y_predicted

scaler.scale_

scale_factor = 1/scaler.scale_
y_predicted *=scale_factor
y_test *=scale_factor

plt.figure(figsize=(12,6))
plt.plot(y_test,'b',label = 'Original Price')
plt.plot(y_predicted,'r',label= 'Predicted Price')
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()





